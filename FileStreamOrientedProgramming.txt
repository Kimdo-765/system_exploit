File Stream Oriented Programming



0. Background
	1. _IO_FILE *fp : single linked list(*_chain points to the next _IO_FILE stucture in the list), the head of the linked list is stored in _IO_list_all

	2. _IO_FILE_plus : 
		a. _IO_FILE file
		b. _IO_jump_t *vtable 

	3. fopen() :
		a. _fopen_internal : it will create a locked_FILE object of the target file and initialize the file descriptor
			1. *new_f = (struct locked_FILE *)malloc(sizeof (struct locked_FILE)); : Allocate a locked_file
			2. _IO_new_file_init_internal(struct _IO_FILE_plus *fp): New fp will be inserted into the singly linked list
			3. _IO_file_fopen((_IO_FILE *) new_f, filename, mode, is32) : get fd and assign the fd to the fp->fileno

	4. _IO_new_file_underflow :
		a. if(fp->_flags & _IO_NO_READS) : Check the fp, if the fd is not readable, return error
		b. if(fp->_IO_buf_base == NULL) : If fp->_IO_buf_base is NULL pointer, call _IO_doallobuf(fp) which set fp->_IO_buf_base and fp->_IO_buf_end
		c. Update the buffer pointer in current fd
		d. count = _IO_SYSREAD(fp, fp->_IO_buf_base, fp->_IO_buf_end - fp->_IO_buf_base); : fp->_IO_buf_base = fp->_IO_buf_end - fp->_IO_buf_base
		e._IO_read_end = fp->_IO_read_end + count;

	5. _IO_new_file_overflow :
		a. if(f->_flags & _IO_NO_WRITES) : Check the fp, If the fd is not writable, return error
		b. if(f->_IO_write_base == NULL) :If fp->_IO_write_base is NULL pointer, call _IO_doallobuf(fp) which set fp->_IO_buf_base and fp->_IO_buf_end
		c. Update the buffer pointer in current fd
		d. return _IO_do_write(f, f->_IO_write_base, f->_IO_write_ptr - f->_IO_write_base); : fp->_IO_write_base = fp->_IO_write_ptr - fp->_IO_write_base

	6. fread() :
		a. _IO_fread : it will first calculate the total bytes to be read into buffer then invoke _IO_file_xsgetn 
			1. if(fp->_IO_buf_base == NULL) : if fp->_IO_buf_base is NULLpointer, call _IO_do_allobuf(fp), set fp->_IO_buf_base and fp->_IO_buf_end
			2. while(want > 0) : set $want to the requested size, set $have to fp->_IO_read_buf - fp->_IO_read_end
			3. memcpy(s, fp->_IO_read_ptr, want); : if $want is less than have, read $want bytes from fp->_IO_read_buf to target buffer
			4. memcpy(s, fp->_IO_read_ptr, have); : if $have is larger than zero, read $have bytes from fp->_IO_read_buf to target buffer
			5. if (fp->_IO_buf_base && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base): if fp->_IO_buf_base is not NULL and $want is less than fp->_IO_buf_end - fp->_IO_buf_base, call __underflow to read data to ->_IO_buf_base and then go to step 2.. Otherwise go to step 4.. 
			6. count = _IO_SYSREAD (fp, s, count); : read requested bytes of data into target buffer 

	7. fwrite() :
		a. _IO_fwrite :it will first calculate the total bytes to be written into file and then invoke _IO_new_file_xcputn for the following steps
			1. set to_do to requested bytes, set $count to the available space in write buffer
			2. if(count > to_do) : if $count is larget than to_do, copy to_do bytes into f->_IO_write_ptr
			3. if(_IO_OVERFLOW (f, EOF) == EOF) : invoke _IO_new_file_overfloww to write data into file. if it reaches the end of file, return. Otherwise, go to step 4.
			4. count = new_do_write (f, s, do_write); : write data into file


1. Attack on _IO_list_all
	1. Conditions
	2. Exploit 
		a. fflush : _IO_flush_all_lockp will be implicitly invoked
		b. _IO_flush_all_lockp will traverse all the _IO_FILE_plus objects in the linked list and trigger _IO_OVERFLOW 
		c. exploit target 1 : _IO_jump_t *vtable of the first object in the linked list, fake vtable can hijack the control flow(jump to vtable)
		d. exploit target 2 : _IO_FILE *chain of the first object in the linked list, fake _IO_FILE_plus object and craft a vtable and hijack control flow in _IO_OVERFLOW
		e. vtable = target_func, *_lock = 0
	3. Value


2. Attack on _IO_2_1_stdin_
	1. Conditions
	2. Exploit
		a. Bypass IO_validate_vtable 1 : find a function to trigger _IO_WIDE_JUMPS_FUNC
		b. Bypass IO_validate_vtable 2 : if fp->_IO_buf_end - fp->_IO_buf_base is larger than requested bytes, it will dirctly read reqeusted bytes of data into fp->_IO_buf_base. After corrupting _IO_stdin->_IO_Buf_end to unsrted bin address, we can use function scanf to overwrites __malloc_hook
		c. Our main target is vtable :)
		e. vtable = target_func, *_lock = 0
	3. Value
