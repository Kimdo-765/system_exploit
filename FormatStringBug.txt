Format String Bug

0. Common FSB Conditions
	1. Vulnerable functions use func(data): fprintf, printf, sprintf, snprintf, vfprintf, vprintf, vsprintf, syslog
	2. %n is int *, %hn is short *


1. Original FSB
	1. Conditions
		a. input data is located at stack (local variables)
	2. Exploit
		a. Check offset from $esp at print_function(input) :
			1. In local machine or binary givem , we can use GDB or something
			2. In remote, we can input <AAAA + "%x" * n> and check offset where AAAA printed
		b. There are 3 considerations : offset, number of format, malicious value
		c. offset : 
			1. if offset == 0, target address is located at offset + number_of_format - 1, we fill 0 ~ offset + number_of_format - 2 with dummy
			2. if offset > 0, target address is located at offset or offset + dummy
		d. number of format : 
			1. In gerneral, we need 2 format, one for setting malicious value, the other for %n
		e. malicious value :
			1. malicious value = 8|4(in 32bit) * n(dummy + target address) + written_bytes_by_format
			2. so, written_bytes_by_format = malicious value - 8 * n
		f. payload = DUMMY + target_address + "%NUMBERx" + "%n" : we write malicious value at target address
	3. Value
		a. Write arbitary value at arbitary address
		

2. Original FSB with over integer malicious value
	1. Conditions
		a. same with Original FSB
		b. high malicious value > low malicious value
	2. Exploit
		a. if malicious value is larger than integer range, we have to devide it to 4|2 Byte 
		b. mali1 = low_mali - 8*prev_input, mali2 = high_mali - low_mali
		c. payload = DUMMY + (target_address) + DUMMY + (target_address+4|2) + mali1 + %hn + mali2 + %hn
	3. Value
		a. Write arbitary value at arbitary address


3. FSB with $-flag
	1. Conditions
		a. We can write '$' on input data
	2. Exploit
		a. Check offset from $esp, same with Original FSB, OFFSET = offset + 1
		b. payload = target_address + "%NUMBERx" + "%OFFSET$n"
	3. Value
		a. Easier to make payload than Original FSB


4. Double Stage FSB
	1. Condition
		a. input data is NOT located at stack
	2. Exploit
		a. Find Pointer at stack over $esp  #pointer : #offset
		b. Stage 1 :
			1. payload = "%TARGET_ADDRESS" + "%OFFSET$n" : *(pointer) = TARGET_ADDRESS
		c. Stage 2 :
			1. Find offset to *pointer : #offset2
			2. payload = "%MALIVALU" + "%OFFSET2$n"
		d. pointer -> target_address = malicious_value 
	3. Value
		a. Bypass Global Input Data 


