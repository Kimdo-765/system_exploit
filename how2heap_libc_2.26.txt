Heap Exploitation glibc version 2.26

0. heap
	1. Chunk
		a. Allocated chunk : prev_size | Size of chunk | Data | Size of next chunk
		b. Free chunk : Chunk | Chunk size | fd | bk | Unused Space | Size of next chunk ( main_arena <bk---fd> chunk1 <bk---fd> chunk2 <bk---fd> main_arena )
	2. Bin
		a. Fast bin : P.fd == next_chunk.prev_size, 16~80 bytes(32~128 bytes in x64), 10 bins, Free chunk Merge X
		b. Small bin : 16~504 bytes, 62 bins, Free chunk Merge
		c. Large bin : 512~ bytes, 63 bins, Free chunk Merge, The fd_nextsize in the large bin chunk points to the first chunk in the list that is smaller than itself, and bk_nextsize points to the first chunk larger than itself.
		d. Unsorted bin : Freed Small, Large chunk, 1 bin( doubly-linked list), FIFO
	3. malloc
	4. free
		a. unlink : prev_inuse?nop:consolidate( P→fd->bk = P→bk; P→bk->fd = P->fd )
	5. tcache 
		a. P.fd == next_chunk.fd, No consolidating
		

1. tcache dup
	1. Conditions
		a. malloc(size) #A 
		b. 2 free(A)
		c. malloc(size)
	2. Exploit
		a. malloc(size) #A
		b. free(A), free(A) : tcache_entry -> A -> A -> A ...
		c. malloc(size), malloc(size), ... #A, #A, ...
	3. Value
		a. Duplicate heap control


2. tcache poisoning
	1. Conditions
		a. 3 malloc(size) #A( writable after free to fd ), #B, #C
		b. free(A)
	2. Exploit 
		a. malloc(size) #A
		b. free(A) : tcache -> &A.fd
		c. A.fd = target_address
		d. 2 malloc(size) #B, #C : B == A, &C == target_address
	3. Value
		a. Manipulate ANY memory to arbitary data
	

3. tcache house of spirit
	1. Conditions
		a. writable fake_chunk( size is least 0x8 if 8 byte aligned or size is least 0x10  )
		b. 2 malloc() #A, #B( writable )
		c. free(&fake_chunk.fd)
	2. Exploit
		a. malloc(any) : set up heap memory
		b. fake_chunk.size = size + header_size
		c. free(&fake_chunk.fd) : &fake_chunk.fd must be 16 byte aligned 
		d. malloc(size) : fake_chunk allocated
	3. Value
		a. Overflow small writable memory
