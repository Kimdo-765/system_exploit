Heap Exploitation glibc version 2.26 based on how2heap

0. heap
	1. Chunk
		a. Allocated chunk : prev_size | Size of chunk | Data | Size of next chunk
		b. Free chunk : Chunk | Chunk size | fd | bk | Unused Space | Size of next chunk ( main_arena <bk---fd> chunk1 <bk---fd> chunk2 <bk---fd> main_arena )
	2. Bin
		a. Fast bin : P.fd == next_chunk.prev_size, 16~80 bytes(32~128 bytes in x64), 10 bins, Free chunk Merge X
		b. Small bin : 16~504 bytes, 62 bins, Free chunk Merge
		c. Large bin : 512~ bytes, 63 bins, Free chunk Merge, The fd_nextsize in the large bin chunk points to the first chunk in the list that is smaller than itself, and bk_nextsize points to the first chunk larger than itself.
		d. Unsorted bin : Freed Small, Large chunk, 1 bin( doubly-linked list), FIFO
	3. malloc
	4. free
		a. unlink : prev_inuse?nop:consolidate( P→fd->bk = P→bk; P→bk->fd = P->fd )
	5. tcache 
		a. P.fd == next_chunk.fd, No consolidating, chunk3.fd ---> chunk2.fd ---> chunk1.fd---> null
		

1. tcache dup
	1. Conditions
		a. malloc(size) #A 
		b. 2 free(A)
		c. malloc(size)
	2. Exploit
		a. malloc(size) #A
		b. free(A), free(A) : tcache_entry -> A -> A -> A ...
		c. malloc(size), malloc(size), ... #A, #A, ...
	3. Value
		a. Duplicate heap control


2. tcache poisoning
	1. Conditions
		a. 3 malloc(size) #A( writable after free to fd ), #B, #C
		b. free(A)
	2. Exploit 
		a. malloc(size) #A
		b. free(A) : tcache => &A.fd
		c. A.fd = target_address : tcache => &A.fd ---> target_address
		d. 2 malloc(size) #B, #C : B == A, &C == target_address
	3. Value
		a. Manipulate ANY memory to arbitary data
	

3. tcache house of spirit
	1. Conditions
		a. writable fake_chunk( size is least 0x8 if 8 byte aligned or size is least 0x10  )
		b. 2 malloc() #A, #B( writable )
		c. free(&fake_chunk.fd)
	2. Exploit
		a. malloc(any) : set up heap memory
		b. fake_chunk.size = size + header_size
		c. free(&fake_chunk.fd) : &fake_chunk.fd must be 16 byte aligned 
		d. malloc(size) : fake_chunk allocated
	3. Value
		a. Overflow small writable memory
		

4. house of botcake
	1. Conditions
		a. 7 malloc(size) #A
		b. 2 malloc(size) #B, #C
		c. malloc(any_size)
		d. free() is free!
		e. C can be double freed
		f. malloc(large_size) #D( writable )
	2. Exploit
		a. 7 malloc(size) #A : for freeing and fill up tcache list later
		b. malloc(size) #B : for later consolidation
		c. malloc(size) #C : victim chunk
		d. malloc(any_size) : for preventing consolidation
		e. 7 free(size) #A : S1. fill up tcache list
		f. free(C) : unsorted bin => C
		g. free(B) : B consolidate with the C
		h. malloc(size) : taking one out from tcache list
		i. free(C) : add C to tcache list *Double Free ocuurs*, tcache => C.fd ---> dum6.fd ---> dum5.fd ...
		j. malloc(large_size) #D 
		k. *(&D + size + 0x10|0x20) = target_address : we can overwrite C.fd to target_address,  tcache => C.fd ---> target_address

		l. malloc(size) : C is poped from tcache list
		m. malloc(size) : target_addr is poped from poisoned tcache list
		n. free(C), overwrite C.fd, 2 malloc(size), repeat 
	3. Value
		a. Manipulate ANY memory to arbitary data in MULTI time
