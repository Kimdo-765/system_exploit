Heap Exploitation

0. heap
	1. Chunk
		a. Allocated chunk : prev_size | Size of chunk | Data | Size of next chunk
		b. Free chunk : Chunk | Chunk size | fd | bk | Unused Space | Size of next chunk ( main_arena <bk---fd> chunk1 <bk---fd> chunk2 <bk---fd> main_arena )
	2. Bin
		a. Fast bin : 16~80 bytes(32~128 bytes in x64), 10 bins, Free chunk Merge X
		b. Small bin : 16~504 bytes, 62 bins, Free chunk Merge
		c. Large bin : 512~ bytes, 63 bins, Free chunk Merge, The fd_nextsize in the large bin chunk points to the first chunk in the list that is smaller than itself, and bk_nextsize points to the first chunk larger than itself.
		d. Unsorted bin : Freed Small, Large chunk, 1 bin( doubly-linked list), FIFO
	3. malloc
	4. free
		a. unlink : prev_inuse?nop:consolidate( P→fd->bk = P→bk; P→bk->fd = P->fd )

		
1. House of Force - Exploit Top Chunk - Negative Size
	1. Conditions
		a. [ malloc() #A : heap overflow to top chunk ]
		b. [ malloc() #B : malloc Size manipulate ] 
		c. [ malloc() #C : writable heap ]
	2. Exploit
		a. malloc()_A : buf_1
		b. Write buf_1.next_size_of_chunk = 0xffffffffffffffff
		c. malloc(Size)_B = target_adress - header_size(0x10 or 0x8) - top_chunk_address - ( target_address' last byte == 0x8 ? [0x8] : [] )
		d. Now, new top_chunk = top_chunk_address + Size( < 0 ) + header_size(0x10 or 0x8) + (size's last byte == 0x8 ? [0x8] : [])
		e. malloc()_C : malloc @ new top_chunk (Target Buf)
	3. Value
		a. Writable to ANY address (e.g @ got)


2. House of Spirit - Exploit Fast Bin - Trick the malloc
	1. Conditions
		a. [ Target buf : writable, known address ] 
		b. [ malloc(ANY) -> free(Target buf) -> malloc(fast_bin_size) ]
	2. Exploit
		a. malloc(ANY)
		b. Write Fake Chunk @ target_buf : size( fast_bin_size ), size of remainder
		c. free(target_buf_address + 0x10) : Now, Fake Chunk is in fast bin
		d. malloc(fast_bin_size) : malloc @ Fake Chunk
	3. Value
		a. Manipulate small stack buf and overwrite RET address (e.g @ret in Stack)
		
		
3. House of Lore - Exploit Small Bin - Trick the bk
	1. Conditions
		a. [ Target Buf : writable, least 2 headers size ]
		b. [ malloc() #A : writable, small bin size ]
		c. [ free(A) ]
		d. [ malloc() #B : large bin size ]
	2. Exploit
		a. Create two Fake Chunk @ Target Buf (Free chunk format)
		b. malloc(small_bin_size) : A
		c. free(A)
		d. Manipulate A.bk to Fake Chunk
		e. malloc(larget_bin_size) : push A from unsorted bin, now A is in small bin
		f. malloc(small_bin_size) : malloc @ A, now Fake Chunk is in small bin
		g. malloc(small_bin_size) : malloc @ Fake Chunk
	3. Value
		a. Manipulate small stack buf and write over size of allocated stack (e.g @ret in Stack)
		
		
4. first-fit - UAF
	1. Conditions
		a. [ malloc(size) #A : target buf ] 
		b. [ free(A) ]
		c. [ malloc(size) : writable heap ]
	2. Exploit
		a. free(A)
		b. malloc(size)
		c. exploit allocated heap
	3. Value
		a. Manipulate heap data
		

5. fastbin_dup - Double free bug
	1. Conditions
		a. [ 3 malloc()_fast_chunk #A, #B, #C ]
		b. [ 3 free(A, B, C) ]
	2. Exploit
		a. malloc 3 fast_chunk
		b. free(A) -> free(B) -> free(A) : make fastbin chain
		c. malloc 3 fast_chunk : A, B, A allocated
	3. Value
		a. Manipulate heap data
		
		
6. fasetbin_dup_into_stack
	1. Conditions
		a. [ Target Stack : writable, least 8 bytes | 16 bytes( x64 ) ] 
		b. [ 3 malloc()_fast_chunk #A, #B, #C ]
		c. [ 2 malloc()_fast_chunk #D( writable ), #E ]
		d. [ 3 free(A, B, C) ]
	2. Exploit
		a. malloc 3 fast_chunk
		b. free(A) -> free(B) -> free(A) : make fastbin chain
		c. malloc 2 fast_chunk : A, B allocated
		d. A.prev_size = stack_address - 0x8 : fastbin{ A -> stack -> A + 0x10 -> NULL }
		e. stack.data = size of A
		d. malloc 2 fast_chunk : A, stack allocated
	3. Value
		a. Manipulate small stack buf and write over size of allocated stack (e.g @ret in Stack)


7. House of einherjar
	1. Conditions
		a. [ 3 malloc #A( writable, BOF to B.prev_size ) ]
		b. [ writable stack : least ( 0x8 | 0x10 ) * 4 ]
		c. [ free(B) ]
		d. [ malloc(Size) ]
	2. Exploit
		a. 3 malloc() #A, #B, #C
		b. Overwirte @ A to B.size.prev_inuse = 0, B.prev_size = &(B) - ( 0x8 | 0x10 ) - &(stack)
		c. *(stack) = Size + a, *(stack + 0x10) = stack, *(stack + 0x18 = stack)
		d. Free(B) : Unsorted Bin = stack
		e. malloc(Size) : stack + 0x10 allocated
	3. Value
		a. Manipulate small stack buf and write over size of allocated stack (e.g @ret in Stack)
		
		
8. Poison null byte - chunksize(P) != prev_size(next_chunk(P)))
	1. Conditions
		a. [ malloc( Size >= 200 ) & free #B( writable to B + Size - 0x10|0x20 ) ]
		b. [ malloc()_fast_bin & free #A( writable, BOF to b.size, #C, #D, #E ]
		c. [ malloc( Size >= D.size + B.size ) ]
	2. Exploit
		a. malloc(fast_bin) #A, malloc(Size >= 200) #B, malloc(fast_bin) #C
		b. *(B + B.size - header_size(0x10|0x20)) = B.size & 0xff00 : Fake prev_size - C is free chunk
		c. free(B)
		d. *BYTE(A + A.size) = 0x00 : B.chunk_size.prev_insue = 0, size - 0x10
		e. malloc()_fast_bin #D, malloc()_fast_bin #E
		f. free(D) : Top Chunk -> D
		g. free(C) : Top Chunk = C - C.prev_size = D
		h. malloc(Size >= D.size + B.size) : overwrite E
	3. Value
		a. Manipulate heap data


9. Overlapping chunks
	1. Conditions
		a. [ 3 malloc() #A( writable, BOF to B.size ), #B, #C ]
		b. [ free(B) ]
		c. [ malloc(Size) ]
	2. Exploit 
		a. 3 malloc() #A, #B, #C
		b. free(B)
		c. Overwrite B.size = B.size + C.size + prev_inuse(1) : B.next_chunk => Top_chunk
		d. malloc(B.size) : Overwrite C
	3. Value
		a. Manipulate heap data


10. Overlapping chunks 2
	1. Conditions
		a. [ 5 malloc() #A( writable, BOF to B.size ), #B, #C, #D, #E ]
		b. [ free(D) ]
		c. [ malloc(Size) ]
	2. Exploit
		a. 5 malloc() #A, #B, #C, #D, #E
		b. free(D)
		c. Overwrite B.size = B.size + C.size + prev_inuse(1) : B.next_chunk => D
		d. free(B) : D.prev_size = B.size + C.size
		e. malloc(Size) : Size= B.size + C.size => Overwrite C
	3. Value
		a. Manipulate heap data
		
		
11. unsorted bin attack
	1. Conditions
		a. [ 2 malloc(small_chunk) #A( writable after free ), #B ]
		b. [ free(A) ]
		c. [ malloc(small_chunk) ]
	2. Exploit 
		a. 2 malooc(fast_chunk) #A, #B
		b. free(A)
		c. Overwrite A.bk = victim - 0x8|0x10
		d. malloc(Size) : Size = A.size - header_size => *(victim) = prev_size, *(victim+0x8) = size,...
	3. Value
		a. if(false){ByPass}Runthis
		
		
12. House of Orange
	1. Conditions
		a. [ malloc() #A( writable, BOF to &top_chunk + 0xc0 ), #B( Very_big_size ), #C( 0x10 ) ]
	2. Exploit 
		a. malloc(Size) #A : Size = small_bin or large_bin
		b. Top_Chunk.size = Top_Chunk.size - PAGE_SIZE * n + 0x1 : e.g) 0x20c01 to 0xc01
		c. malloc(Size) #B : Size = Very_big_size : sysmalloc & _int_free is invoked, now new top chunk allocated and Unsorted_bin = prev_top_chunk
		d. Overwrite free_chunk.prev_size = "/bin/sh", free_chunk.size = size_small_chunk[4], free_chunk.bk = &_IO_list_all - 0x10
		e. Make fake_fp @ &free_chunk
			1. fp->_mode = 0 : &free_chunk + 0xc0
			2. fp->_IO_write_base = 2 : &free_chunk + 0x20
			3. fp->_IO_write_ptr = 3 : &free_chunk + 0x28
			4. _IO_jump_t[3] = &system() : jump_table = &controlled_momory, jump_table[3] = &system, jump_*(&free_chunk + 0xd8) = jump_table
		f. malloc(10) : _IO_list_all = <main_arena+88> => free_chunk is switched to smallbin[4] => smallbin[4] is <main_arena+88>+0x68(next fp in _IO_list_all) => detect "size <= 2 * SIZE_SZ" => call _IO_OVERFLOW() : system("/bin/sh")
	3. Value
		a. Execute arbitary function
		

13. unsafe unlink
	1. Conditions
		a. [ 2 malloc[0x80] #A( writable, BOF to B.size ), #B ]
		b. [ free(B) ]
		c. [ global pointer buf1( writable through pointer ) ]
	2. Exploit
		a. 2 malloc(0x80) #A, #B
		b. global buf1 = &A 
		c. Create Fake Chunk, (&A + 0x10) = 0x0, (&A + 0x18) = 0x0, (&A + 0x20) = &buf1 - 0x18, (&A + 0x28) = &buf - 0x10 : P.next_chunk = P, P->fd->bk == P, P->bk->fd == P
		d. B.prev_size = 0x80, B.size = 0x90 (delete prev_inuse)
		e. free(B) : consolidate works, buf1 = fake_chunk.fd(&buf1 - 0x18)
		f. Overwrite buf1 : *buf1 = "A"*0x18 + target_address, e.g) GOT
		g. Overwrite target_address : *buf1 = something, e.g) &system
	3. Value
		a. Manipulate ANY memory that is writable to arbitary data
		
		
14. large bin attack
	1. Conditions
		a.
	2. Exploit
		a. malloc(large_chunk) #A
		b. malloc(fast_chunk) : prevent consolidating #A with #B
		c. malloc(large_chunk.larger_than_A) #B
		d. malloc(fast_chunk) : prevent consolidating #B with #C
		e. malloc(B.size - header_size) #C
		f. malloc(fast_chunk) : prevent consolidating #C with top chunk
		g. free(A), free(B) : unsorted bin [ B <---> A ]
		h. malloc(size <= A.size) #D : B is moved to large bin freelist, parts of A is allocated and the remaining of the freed firtst large chunk into the unsorted bin[ &A + d.size + header_size ], large bin[ B ]
		i. free(C) : unsorted bin [ C <---> &A + D.size + header_size ], large bin[ B ]
		j. B.size = large_chunk.smaller_than_A, B.fd = 0, B.bk = target_address1 - 0x10, B.fd_nextsize = 0, B.bk_nextsize = target_address2 - 0x20
		k. malloc(D.size) : large bin [ target_address1 - 0x10 <bk--- B ] => [ C <bk--- target_address - 0x10 <bk--- B ], target_address1 = &C, target_address2 = &C
	3. Value
		a. Manipulate ANY momory that is writable to &C
		
		
15. Double Free Bug
16. tcache poisoning